/**
 * slip.c
 *
 *  Created on: 19.12.2016
 *  Author: Tobias
 *  Downloaded from: https://github.com/lobaro/util-slip
 *  License: https://github.com/lobaro/util-slip/blob/master/LICENSE
 */
#include <stdbool.h>
#include <stdint.h>
#include <assert.h>
#include "slip.h"

/* SEND_PACKET: sends a packet of length "len", starting at
 * location "p".
 */
void slip_send_packet(uint8_t *p, int len, SerialPort* serial) {

    /* send an initial END character to flush out any data that may
     * have accumulated in the receiver due to line noise
     */
    serial_send_byte(serial, SLIP_END);

    slip_encode(p, len, serial);

    /* tell the receiver that we're done sending the packet
     */
    serial_send_byte(serial, SLIP_END);
}

void slip_encode(const uint8_t* p, int len, SerialPort* serial) {
    /* for each byte in the packet, send the appropriate character
     * sequence
     */
    while (len--) {
        switch (*p) {
            /* if it's the same code as an END character, we send a
             * special two character code so as not to make the
             * receiver think we sent an END
             */
            case SLIP_END:
                serial_send_byte(serial, SLIP_ESC);
                serial_send_byte(serial, SLIP_ESC_END);
                break;

                /* if it's the same code as an ESC character,
                 * we send a special two character code so as not
                 * to make the receiver think we sent an ESC
                 */
            case SLIP_ESC:
                serial_send_byte(serial, SLIP_ESC);
                serial_send_byte(serial, SLIP_ESC_ESC);
                break;
                /* otherwise, we just send the character
                 */
            default:
                serial_send_byte(serial, *p);
        }
        p++;
    }
}


/* RECV_PACKET: reads a packet from buf into the buffer located at "p".
 *      If more than len bytes are received, the packet will
 *      be truncated.
 *      Returns the number of bytes stored in the buffer.
 */
int slip_read_packet(uint8_t *p, int len, SerialPort* serial) {
    uint8_t c;
    int bytes_received = 0;

    /* sit in a loop reading bytes until we put together
     * a whole packet.
     * Make sure not to copy them into the packet if we
     * run out of room.
     */
    while (1) {

        int status = serial_recv_bytes(serial, &c, 1);
        /* handle bytestuffing if necessary
         */
        switch (c) {

            /* if it's an END character then we're done with
             * the packet
             */
            case SLIP_END:
                /* a minor optimization: if there is no
                 * data in the packet, ignore it. This is
                 * meant to avoid bothering IP with all
                 * the empty packets generated by the
                 * duplicate END characters which are in
                 * turn sent to try to detect line noise.
                 */
                if (bytes_received) {
                    return bytes_received;
                }
                else {
                    break;
                }

                /* if it's the same code as an ESC character, wait
                 * and get another character and then figure out
                 * what to store in the packet based on that.
                 */
            case SLIP_ESC:
                status = serial_recv_bytes(serial, &c, 1);

                /* if "c" is not one of these two, then we
                 * have a protocol violation.  The best bet
                 * seems to be to leave the byte alone and
                 * just stuff it into the packet
                 */
                switch (c) {
                    case SLIP_ESC_END:
                        c = SLIP_END;
                        break;
                    case SLIP_ESC_ESC:
                        c = SLIP_ESC;
                        break;
                }
                // Store the character
                if (bytes_received < len) {
                    p[bytes_received++] = c;
                }
                break;
            default:
                // Store the character
                if (bytes_received < len) {
                    p[bytes_received++] = c;
                }
        }
    }
}